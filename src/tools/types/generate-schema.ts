// Main file to generate the type schema and type-checking functions.

import * as fs from 'fs';

import { Types } from '../../shared/type-definitions';
import { assertNonNull } from '../../shared/language';

export function generateSchemaFile(config: TypesConfig, noChanges: boolean) {
  if (Object.keys(config.schema).length === 0) {
    console.log(`  Schema for ${config.kind} is empty, skipping.`);
    return;
  }
  const schema = JSON.stringify(config.schema, null, 2);
  const path = `${config.absolutePathToSchema}/schema.json`;
  if (fs.existsSync(path) && fs.lstatSync(path).isFile()) {
    if (fs.readFileSync(path).toString() == schema) {
      console.log(`  Schema for ${config.kind} already up to date.`);
      return;
    }
  }

  // Test is not checked in, so we don't check.
  if (noChanges && config.kind !== 'test') {
    console.log(
      `Schema for '${config.kind}' is not up to date, please generate it using 'yarn codegen'.`
    );
    process.exit(1);
  }

  fs.writeFileSync(path, schema);
  console.log(`  Generated schema for ${config.kind}.`);
}

export function generateCheckingFunctionsFile(config: TypesConfig) {
  if (Object.keys(config.schema).length === 0) {
    return;
  }
  if (config.functions === undefined) return;
  const filenameToType: { [key: string]: string[] } = {};
  for (const type of Object.values(config.schema)) {
    // It's a mystery to me why I need to declare the type of filename, but if I don't, typescript complains.
    // If I do, eslint complains, which I disable here:

    const filename: string = config.functions.pathFromSchemaToType(
      assertNonNull(type.filename).replace(/\.tsx?$/, '')
    );
    if (!(filename in filenameToType)) filenameToType[filename] = [];
    filenameToType[filename].push(assertNonNull(type.name));
  }
  const hasAdditionalSchema =
    config.functions.pathToAdditionalSchemaFromSchema !== undefined;
  const functions = `// IMPORTANT: This file is automatically generated by ${__filename}, do not manually change it.

/* eslint-disable */
import { Type, Types } from '${
  config.functions.pathToSharedFromSchema('type-definitions')
  }';
import { NotPromise, checkValueAgainstType, computePropertiesOfType } from '${
    config.functions.pathToSharedFromSchema('check-type')
  }';
import mainSchema from './schema.json';
${
  hasAdditionalSchema
    ? `import additionalSchema from '${config.functions.pathToAdditionalSchemaFromSchema}/schema.json';`
    : ''
}

${Object.entries(filenameToType)
  .map(entry => `import { ${entry[1].join(', ')} } from './${entry[0]}';`)
  .join('\n')}

const schema = ${
    hasAdditionalSchema
      ? `{ ...mainSchema, ...additionalSchema }`
      : `mainSchema`
  }

export function propertiesOfType(typeName: ${Object.keys(config.schema)
    .map(name => `'${name}'`)
    .join(' | ')}): string[] {
  return computePropertiesOfType(schema as Types, schema[typeName] as unknown as Type);
}

${Object.values(config.schema)
  .map(
    type => `export function assert${type.name}<T>(value: NotPromise<T>): ${type.name} {
  const error = checkValueAgainstType(value, schema['${type.name}'] as unknown as Type, schema as Types);
  if (error != '') throw new Error(error);
  return value as unknown as ${type.name};
}`
  )
  .join('\n\n')}
`;
  const path = `${config.absolutePathToSchema}/check-type.generated.ts`;
  if (fs.existsSync(path) && fs.lstatSync(path).isFile()) {
    if (fs.readFileSync(path).toString() == functions) {
      console.log(
        `  Type checking functions for ${config.kind} already up to date.`
      );
      return;
    }
  }

  fs.writeFileSync(path, functions);
  console.log(`  Generated type checking functions for ${config.kind}.`);
}

export type TypesConfig = {
  kind: string;
  absolutePathToSchema: string;
  schema: Types;
  functions?: {
    pathToSharedFromSchema: (filename: string) => string;
    pathFromSchemaToType: (filename: string) => string;
    pathToAdditionalSchemaFromSchema?: string;
  };
};
